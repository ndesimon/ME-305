Closed-\/loop speed control of DC motors.\hypertarget{lab4page_8py_sec_intro4}{}\doxysection{Introduction}\label{lab4page_8py_sec_intro4}
Lab 4 introduces task and driver files to accomodate proportional and integral speed control of DC motors. The closed-\/loop controller reads from the motors\textquotesingle{} quadrature encoders for error feedback, as well as accepts user-\/input controller gains Kp and Ki to compute motor actuation signals based on the error in motor velocity versus the user-\/ input velocity setpoint. Please see \mbox{\hyperlink{lab4page_8py_sec_files4}{Project Files}} for descriptions of our project files.

Note the following block diagram for observation of our closed-\/loop controller\+: \hypertarget{lab4page_8py_sec_res4}{}\doxysection{Results}\label{lab4page_8py_sec_res4}
The Lab 4 firmware is able to conduct user-\/defined velocity step response tests on the DC motor, which allow for observation of the controller\textquotesingle{}s performance in relation to the user defined controller gains and velocity setpoint. Please see {\bfseries{Figures 1-\/3}} for three step response tests, each conducted with a velocity setpoint of 100 \mbox{[}rad/s\mbox{]} and variable Kp/\+Ki controller gains. Note subsequent evaluations of their controller performance, including steady-\/state error and settling time.

\begin{center}  {\bfseries{Figure 1\+:}} The first step-\/response test was conducted with a Kp of 0.\+25 \mbox{[}\%$\ast$s/rad\mbox{]} and Ki of 20 \mbox{[}Hz\mbox{]}. Note the acceptable steady-\/state error of -\/0.\+80 \mbox{[}rad/s\mbox{]} and lack of overshoot, but the relatively slow settling time of 0.\+404 \mbox{[}sec\mbox{]}.\end{center} 

\begin{center}  {\bfseries{Figure 2\+:}} The second step-\/response test was conducted with a Kp of 0.\+50 \mbox{[}\%$\ast$s/rad\mbox{]} and Ki of 20 \mbox{[}Hz\mbox{]}. Note the steady-\/state error and settling time have both decreased, as compared to {\bfseries{Figure 1}}, to -\/0.\+59 \mbox{[}rad/s\mbox{]} and 0.\+26 \mbox{[}sec\mbox{]}, respectively. However, the increased Kp value produced undesirable overshoot of both the motor\textquotesingle{}s angular velocity and actuation signal, which should be mitigated through further tuning of the controller gains. ~\newline
\end{center} 

\begin{center}  {\bfseries{Figure 3\+:}} The third step-\/response test was conducted with a Kp of 0.\+25 \mbox{[}\%$\ast$s/rad\mbox{]} and Ki of 50 \mbox{[}Hz\mbox{]}. Note the settling time has decreased further to 0.\+129 \mbox{[}sec\mbox{]}, although the steady-\/state error returns to around 0.\+78 \mbox{[}rad/s\mbox{]}. However, oscillation is minimized, which we have chosen to optimize over settling time. \end{center} \hypertarget{lab4page_8py_sec_files4}{}\doxysection{Project Files}\label{lab4page_8py_sec_files4}
\hypertarget{lab4page_8py_sub_main4}{}\doxysubsection{Main File}\label{lab4page_8py_sub_main4}
The main file instantiates our task-\/ and class-\/files as objects to be run asynchronously. Note the task diagram below for information regarding file communication and run frequency. See \mbox{\hyperlink{main_8py}{main.\+py}} for more information. \hypertarget{lab4page_8py_sub_utask4}{}\doxysubsection{User Task}\label{lab4page_8py_sub_utask4}
The user interface is written as a generator function that prints to a terminal emulator. It is able to read a user\textquotesingle{}s keyboard presses as encoder, motor driver, and controller commands, such as printing the encoder\textquotesingle{}s position in ticks or accepting user-\/input controller gain and velocity setpoint values, over the USB virtual comm port. See \mbox{\hyperlink{_u_task_8py}{UTask.\+py}} for more information and the figure below for the User Task\textquotesingle{}s state transition diagram. \hypertarget{lab4page_8py_sub_ctask4}{}\doxysubsection{Controller Task}\label{lab4page_8py_sub_ctask4}
The controller task communicates controller gain values, Kp and Ki, and motor velocity setpoints to our closed-\/loop driver, \mbox{\hyperlink{closedloop_8py}{closedloop.\+py}}. This task is also responsible for sending duty cycles to the motor task, which enables motor actuation according to the actuation signal computed in the closed-\/loop driver. See \mbox{\hyperlink{_c_task_8py}{CTask.\+py}} for more information and the figure below for the Controller Task\textquotesingle{}s state transition diagram. \hypertarget{lab4page_8py_sub_mtask4}{}\doxysubsection{Motor Task}\label{lab4page_8py_sub_mtask4}
The motor task sends duty cycles, which are determined as the actuation signal of the closed-\/loop controller, to their respective motors, either Motor 1 or Motor 2. See \mbox{\hyperlink{_m_task_8py}{MTask.\+py}} for more information and the figure below for the Motor Task\textquotesingle{}s state transition diagram. \hypertarget{lab4page_8py_sub_stask4}{}\doxysubsection{Safety Task}\label{lab4page_8py_sub_stask4}
The safety task enables and disables the motors according to the user\textquotesingle{}s keyboard presses, or at the occurence of faults triggered by the motor driver chip, the DRV8847. See \mbox{\hyperlink{_s_task_8py}{STask.\+py}} for more information and the figure below for the Safety Task\textquotesingle{}s state transition diagram. \hypertarget{lab4page_8py_sub_etask4}{}\doxysubsection{Encoder Task}\label{lab4page_8py_sub_etask4}
The encoder task uses a generator function to update a shared tuple, enc\+Data, that stores time \mbox{[}ms\mbox{]}, position \mbox{[}ticks\mbox{]}, and position changes \mbox{[}ticks/sec\mbox{]}. See \mbox{\hyperlink{_e_task_8py}{ETask.\+py}} for more information and the figure below for the Encoder Task\textquotesingle{}s state transition diagram. \hypertarget{lab4page_8py_sub_clc4}{}\doxysubsection{Closed-\/\+Loop Control Driver}\label{lab4page_8py_sub_clc4}
The closed-\/loop driver is a class file that computes actuation signals according to user-\/defined controller gains, Kp and Ki, and desired motor velocity setpoints. The controller is able to perform proportional and/or integral closed-\/loop control. See \mbox{\hyperlink{closedloop_8py}{closedloop.\+py}} for more information.\hypertarget{lab4page_8py_sub_mot4}{}\doxysubsection{Motor Driver}\label{lab4page_8py_sub_mot4}
The motor driver is a class file that instantiates timer and timer channel objects for the designated motor\textquotesingle{}s PWM channels, which are configured as inverted PWM channels. The driver also has a method to set motor duty cycles as a pulse width percent, whose value is determined by the user\textquotesingle{}s entered duty cycle. See \mbox{\hyperlink{motor_8py}{motor.\+py}} for more information.\hypertarget{lab4page_8py_sub_drv4}{}\doxysubsection{DRY8847 Driver}\label{lab4page_8py_sub_drv4}
The DRV8847 class file handles control of our physical motor driver, the DRV8847. Its associated methods include enabling and disabling the driver\textquotesingle{}s enable pin, clearing motor faults triggered by the driver\textquotesingle{}s fault pin, or specifying motor pin, timer, and timer channel values, all of which are called either in \mbox{\hyperlink{main_8py}{main.\+py}} or in the safety task, \mbox{\hyperlink{_s_task_8py}{STask.\+py}}. See \mbox{\hyperlink{_d_r_v8847_8py}{DRV8847.\+py}} for more information.\hypertarget{lab4page_8py_sub_enc4}{}\doxysubsection{Encoder Driver}\label{lab4page_8py_sub_enc4}
The encoder driver is a class file that instantiates timer and timer channel objects and has various methods for reading data from the encoder. See \mbox{\hyperlink{encoder_8py}{encoder.\+py}} for more information.\hypertarget{lab4page_8py_sub_sha4}{}\doxysubsection{Shares Class}\label{lab4page_8py_sub_sha4}
The shares class file allows variables to be created, read from, and written to multiple files. See \mbox{\hyperlink{shares_8py}{shares.\+py}} for more information. 